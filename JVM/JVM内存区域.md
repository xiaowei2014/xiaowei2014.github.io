# JVM内存区域

[转自](https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247487873&idx=3&sn=157ea6657a72f71373e014abc186441e&chksm=fbb2987fccc51169927b22f1048666fa9122901153060308e162c1f763f3b279ef1bd75bbb45&scene=21#wechat_redirect)

### 0 运行时数据区域

Java 虚拟机所管理的内存一共分为Method Area（方法区）、VM Stack（虚拟机栈）、Native Method Stack（本地方法栈）、Heap（堆）、Program Counter Register（程序计数器）五个区域。

这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：

![img](JVM内存区域1.png)

上图介绍的是JDK1.8 JVM运行时内存数据区域划分。1.8同1.7比，最大的差别就是：**元数据区取代了永久代**。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存**。

### 1 程序计数器（Program Counter Register）

**程序计数器（Program Counter Register）**是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。在虚拟机概念模型中，**字节码解释器**工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

程序计数器是一块 **“线程私有”** 的内存，每条线程都有一个独立的程序计数器，能够将切换后的线程恢复到正确的执行位置。

- 执行的是一个**Java方法**

计数器记录的是正在执行的**虚拟机字节码指令的地址**。

- 执行的是**Native方法**

**计数器为空（Undefined）**，因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。

- 程序计数器也是唯一一个在Java虚拟机规范中没有规定任何**OutOfMemoryError**情况的内存区域。

### 2 Java虚拟机栈（Java Virtual Machine Stacks）

![img](JVM内存区域2.png)

**Java虚拟机栈（Java Virtual Machine Stacks）**描述的是**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**，从上图中可以看出，栈帧中存储着**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。每一个方法从调用直至执行完成的过程，会对应一个栈帧在虚拟机栈中入栈到出栈的过程。

与程序计数器一样，Java虚拟机栈也是**线程私有**的。

而**局部变量表**中存放了编译期可知的各种：

- **基本数据类型**(boolen、byte、char、short、int、 float、 long、double）
- **对象引用**（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
- **returnAddress类型**（指向了一条字节码指令的地址）

其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

Java虚拟机规范中对这个区域规定了两种异常状况：

- **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。
- **OutOfMemoryError**：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。

一直觉得上面的概念性的知识还是比较抽象的，下面我们通过JVM参数的方式来控制栈的内存容量，模拟StackOverflowError异常现象。

### 3 本地方法栈（Native Method Stack）

**本地方法栈（Native Method Stack）** 与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至**有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一**。与虚拟机一样，本地方法栈会抛出**StackOverflowError**和**OutOfMemoryError**异常。

- 使用-Xss参数减少栈内存容量



### 4 Java堆（Heap）

对于大多数应用而言，**Java堆（Heap）**是Java虚拟机所管理的内存中最大的一块，它**被所有线程共享的**，在虚拟机启动时创建。此内存区域**唯一的目的**是**存放对象实例**，几乎所有的对象实例都在这里分配内存，且每次分配的空间是**不定长**的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存**对象实例的属性值**，**属性的类型**和**对象本身的类型标记**等，**并不保存对象的方法（方法是指令，保存在Stack中）**,在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。

Java堆是垃圾收集器管理的主要区域，因此也被称为 **“GC堆（Garbage Collected Heap）”** 。从内存回收的角度看内存空间可如下划分：

![img](JVM内存区域3.png)

图片摘自https://blog.csdn.net/bruce128/article/details/79357870

- **新生代（Young）**：新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。

如果把新生代再分的细致一点，新生代又可细分为**Eden空间**、**From Survivor空间**、**To Survivor空间**，默认比例为8:1:1。

- **老年代（Tenured/Old）**：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。
- **永久代（Perm）**：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。

其中**新生代和老年代组成了Java堆的全部内存区域**，而**永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现**

另外，再强调一下堆空间内存分配的大体情况，这对于后面一些Jvm优化的技巧还是有帮助的。

- 老年代 ：三分之二的堆空间
- 年轻代 ：三分之一的堆空间
    eden区：8/10 的年轻代空间
    survivor0 : 1/10 的年轻代空间
    survivor1 : 1/10 的年轻代空间



### 5 方法区（Method Area）

**方法区（Method Area）** 与Java堆一样，是各个线程共享的内存区域。它用于存储一杯`虚拟机加载`的**类信息、常量、静态变量、及时编译器编译后的代码**等数据。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 **Non-Heap**。

**运行时常量池（Runtime Constant Pool）**

**运行时常量池（Runtime Constant Pool）**是方法区的一部分。**Class文件**中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，**这部分内容将在类加载后进入方法区的运行时常量池存放**。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备**动态性**，Java语言并不要求常量一定只有编译器才能产生，也就是**并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中**。String.intern()是一个`native`方法



JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

![img](运行时常量池.jpg)



### 6 直接内存

**直接内存（Direct Memory）**并不是虚拟机**运行时数据区**的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致**OutOfMemoryError**异常出现。

这个我们实际中主要接触到的就是NIO，在NIO中，我们为了能够加快IO操作，采用了一种直接内存的方式，使得相比于传统的IO快了很多。

在NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配**堆外内存**，然后通过一个存储在Java堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。